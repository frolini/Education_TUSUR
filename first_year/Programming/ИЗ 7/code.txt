/*Дан массив размера N. Продублировать в нем элементы с четными номерами (2,
4, . . .). Условный оператор не использовать.*/

#include <stdlib.h>
#include <stdio.h>

int* fun(int* arr, int* N)
{
	//Обновляем длинну массива, учитывая что нам надо продублировать каждый чётный номер
	int oldN = (*N);
	*N = (*N) + ((*N) / 2);
	//Выделяем память под новый массив
	int* res = malloc(sizeof(int) * (*N));
	int indexForRes = 0;
	//Перебираем все элементы исходного массива
	for (int i = 0; i < oldN; i++)
	{
		//Если индекс нечётный(т.е номер чётный), тогда записываем число, из первоначального массива в обработанный, дважды
		if (i % 2 != 0)
		{
			for (int j = 0; j < 2; j++)
			{
				res[indexForRes++] = arr[i];
			}
		}
		//Иначе только 1 раз
		else
		{
			res[indexForRes++] = arr[i];
		}
	}
	//Чистим память от старого массива и вохвращаем обработанный
	free(arr);
	return res;
}

int main()
{
	//Генерируем первоначальный массив
	int N = 20;
	int* arr = malloc(sizeof(int) * N);
	for (int i = 0; i < N; i++)
	{
		arr[i] = rand() % 100;
		printf("%d ", arr[i]);
	}
	//Получаем обработанный массив
	arr = fun(arr, &N);
	printf("\n\n");
	for (int i = 0; i < N; i++)
	{
		printf("%d ", arr[i]);
	}
	getch();
	return 0;
}